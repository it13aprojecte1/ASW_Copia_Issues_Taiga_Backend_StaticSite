Paulaa <3
._pauli_
Invisible

[10:55]fr4n99._.: https://insightmaker.com/insight/2nPWRjZGqerpxMtCvVAtmW/SEIRD-01-COVID-19-spread
SEIRD 01: COVID-19 spread
Here we have a basic SEIR model and we will investigate what changes would be appropriate for modelling the 2019 Coronavirus. The initial parametrization is based on the suggested current data. The initial population is set for Catalonia.
SEIRD 01: COVID-19 spread
[10:55]Paulaa <3[cute]
: https://insightmaker.com/insight/1rT16SGjQ5H58kD1tdX8xk
Pràctica4
Pràctica4
[10:59]fr4n99._.: https://insightmaker.com/insight/6oDGURQfpVAsYZtttIFUuz/Clone-of-SEIRD-01-COVID-19-spread
Clone of SEIRD 01: COVID-19 spread
Here we have a basic SEIR model and we will investigate what changes would be appropriate for modelling the 2019 Coronavirus. The initial parametrization is based on the suggested current data. The initial population is set for Catalonia.
Clone of SEIRD 01: COVID-19 spread
[10:59]fr4n99._.: https://insightmaker.com/insight/6oDGURQfpVAsYZtttIFUuz/Clone-of-SEIRD-01-COVID-19-spread
Clone of SEIRD 01: COVID-19 spread
Here we have a basic SEIR model and we will investigate what changes would be appropriate for modelling the 2019 Coronavirus. The initial parametrization is based on the suggested current data. The initial population is set for Catalonia.
Clone of SEIRD 01: COVID-19 spread
[10:59]fr4n99._.: https://insightmaker.com/insight/6oDGURQfpVAsYZtttIFUuz/Clone-of-SEIRD-01-COVID-19-spread
Clone of SEIRD 01: COVID-19 spread
Here we have a basic SEIR model and we will investigate what changes would be appropriate for modelling the 2019 Coronavirus. The initial parametrization is based on the suggested current data. The initial population is set for Catalonia.
Clone of SEIRD 01: COVID-19 spread
[11:48]Paulaa <3[cute]
: https://insightmaker.com/insight/1wSzONzOXm4ESLjJKysDdm
Model2
Model2
[11:49]fr4n99._.: https://insightmaker.com/insight/1rT16SGjQ5H58kD1tdX8xk/Model1
[11:49]fr4n99._.: Model 1
[9:14]fr4n99._.: http://nattech.fib.upc.edu:40421/swagger/
[10:16]fr4n99._.:
Imagen
[14:07]fr4n99._.: hacemos sim luego despues del barça
[14:07]fr4n99._.: ?
[14:07]Paulaa <3[cute]
: vale
[18:27]fr4n99._.: Me ducho y sobre las 7 me pongo con sim
[18:35]Paulaa <3[cute]
: vale
[18:54]Paulaa <3[cute]
: estoy listo
[18:54]fr4n99._.: Aún no me he duchado un rato
[18:54]fr4n99._.: Ves mirando lo que haya q hacer y ves abriendo el insigne maker y tal
[18:54]Paulaa <3[cute]
: ok
[19:14]fr4n99._.: estoy
Paulaa <3
 ha iniciado una llamada que ha durado 2 horas. — 11/5/25, 19:14
[19:15]fr4n99._.:
Imagen
[19:19]fr4n99._.:
Imagen
[19:24]fr4n99._.: beta * 0.01 * C * I / N
[19:27]fr4n99._.:
Imagen
[19:28]fr4n99._.: beta * 0.01 * C * I / N
[20:05]Paulaa <3[cute]
: https://insightmaker.com/edit/351NpVCdKZieAnQXx07vNf/access
[20:06]Paulaa <3[cute]
: https://insightmaker.com/insight/351NpVCdKZieAnQXx07vNf/Model3
[20:18]Paulaa <3[cute]
: https://insightmaker.com/insight/56x8PQeAS3eJAOq8cQimJT/Model4
[20:23]fr4n99._.: if Time < 270 then beta_base
else if Time < 300 then beta_base * 1.5
else if Time < 400 then beta_base * 2
else beta_base * 4
[20:41]Paulaa <3[cute]
: https://insightmaker.com/insight/50vAjLWPoVU26saSEDnJu1/Model5
[20:59]fr4n99._.: victor.garcia.carrasco@upc.edu
[20:31]fr4n99._.: rails s -p 8080 -s 0.0.0.0
[23:33]Paulaa <3[cute]
:
openapi: 3.0.2
info:
  version: 1.0.0
  title: OnTime API
  description: "API REST para la aplicación OnTime, un clon de Taiga. Esta API proporciona acceso a todas las funcionalidades implementadas en la aplicación web."
servers:
Expandir
message.txt
27 KB
[12:44]fr4n99._.: ac2e67dee04a8693723f772b008dac56
[13:23]fr4n99._.: 9dadd630322714d782fc009df5667b81
[13:23]fr4n99._.: ---
[13:23]fr4n99._.: cMZ5vXG+f1EkkoUuYQWQJEJbfcTXaDNFfQagJ8PAfGpS3V6Ha/LggCI6K0GwwgXV0AXdxYAT4o3yaz6NP8kQzaB7o6F8ikbuHYndu7I6j3xORWklVsrZMbQRI3aQ1c7DsI7yiReCvaXGGeNJZB3y9BXYUyKJxtDHpQaAXqxR9rEXEDkgXp1VwPCziWzcKvZsRyEXYvl6rdr0yO4o66SublXuaMRIE07TyTcT/zfXr6rkbRMQ5ADMmLRzO5NHTZ6FmwaOo7XtX2vvcdIDFSKSS99UiuO7ys8Vbays9W8Br8rXUmaoDSiyo4T5OUpoJrv6xu0sdRIOmTPF8UcMSOtzME2Q+r7CEhj+HXXiBU0qo91Bt47rY89Pnzdh9Pxjq5Uf2kHhRnf4AYqC1d7XMEYwEW0qRTD5qnYSz7a9ZMU0oGpoAcQUidt6jLQ7G508vnk/nROGr8I2COH4d0PK1lxnO35nYLFufchmNmjpNHLBwSemxdq79K838xp6--pYIqjFTPbQpme2Tz--tzFpw6I1LKde3pp+DxE9Wg==
[13:29]Paulaa <3[cute]
: ----
[13:29]Paulaa <3[cute]
: https://waslab04-p1hk.onrender.com/users/sign_in
[13:31]fr4n99._.: client id
[13:31]fr4n99._.: Ov23liL9B4uH5DWLjN95
[13:32]fr4n99._.: secrete github key
[13:32]fr4n99._.: 27314aa94a3d82465eb5c18dd3d21234714b40ba
[13:33]fr4n99._.:
openapi: 3.0.2
info:
  version: 1.0.0
  title: OnTime API
  description: "API REST para la aplicación OnTime, un clon de Taiga. Esta API proporciona acceso a todas las funcionalidades implementadas en la aplicación web."
servers:
Expandir
message.txt
43 KB
[18:37]Paulaa <3[cute]
: disc???
[18:38]fr4n99._.: toy en aws
[18:38]fr4n99._.: asw
[18:38]Paulaa <3[cute]
: voy
[18:38]Paulaa <3[cute]
: 1sec
[18:57]fr4n99._.: databases:

name: waslab04
  databaseName: waslab04
  user: waslab04
  plan: free,

services:

type: web
  name: waslab04
  runtime: ruby
  plan: free
  buildCommand: "./bin/render-build.sh"# preDeployCommand: "bundle exec rails db:migrate" # preDeployCommand only available on paid instance types
  startCommand: "bundle exec rails db:seed;bundle exec rails server -b 0.0.0.0 -p 8080"
  envVars:
key: DATABASE_URL
    fromDatabase:
      name: waslab04
      property: connectionString
key: RAILS_MASTER_KEY
  sync: false
key: WEB_CONCURRENCY
value: 2 # sensible default,
key: AWS_ACCESS_KEY_ID
sync: false,
key: AWS_SECRET_ACCESS_KEY
sync: false,
key: AWS_SESSION_TOKEN
sync: false,
key: GITHUB_APP_ID
sync: false,
key: GITHUB_APP_SECRET
sync: false,
key: GITHUB_CALLBACK_URL
sync: false,
,
,
,
[18:58]fr4n99._.: databases:

name: waslab04
  databaseName: waslab04
  user: waslab04
  plan: free,

services:

type: web
  name: waslab04
  runtime: ruby
  plan: free
  buildCommand: "./bin/render-build.sh"# preDeployCommand: "bundle exec rails db:migrate" # preDeployCommand only available on paid instance types
  startCommand: "bundle exec rails db:seed;bundle exec rails server -b 0.0.0.0 -p 8080"
  envVars:
key: DATABASE_URL
    fromDatabase:
      name: waslab04
      property: connectionString
key: RAILS_MASTER_KEY
  sync: false
key: WEB_CONCURRENCY
value: 2 # sensible default,
key: AWS_ACCESS_KEY_ID
sync: false,
key: AWS_SECRET_ACCESS_KEY
sync: false,
key: AWS_SESSION_TOKEN
sync: false,
key: GITHUB_APP_ID
sync: false,
key: GITHUB_APP_SECRET
sync: false,
key: GITHUB_CALLBACK_URL
sync: false,
,
,
,
[18:58]fr4n99._.:
databases:
  - name: waslab04
    databaseName: waslab04
    user: waslab04
    plan: free
Expandir
caca.txt
1 KB
[19:04]fr4n99._.: crendenciales amazon
[19:04]fr4n99._.: aws_access_key_id=ASIA5KUMSLDOSLJW7LW2
aws_secret_access_key=9reVSYN0fKNFsxgICS+DdR4hl3qaFMJqQV3Jmv1s
aws_session_token=IQoJb3JpZ2luX2VjEHgaCXVzLXdlc3QtMiJHMEUCIBuKBkOawf4OfsSHBjRaGgCFSHfFVY0r1BO/ruU8+1zPAiEAkGRXT8q9nCmE60sXjlJIhzVl5EmWuTQ16dvux4WMFvoqxAIIMRAAGgw5MTYxOTY1Nzk1NDkiDC+q9y/yMovZoL77giqhAttzsjRIrIE01MB6ITuUIhTzs6qIsveJnG3sXDz1PaUrW/WiKlqRVu3kyYzj8m5C0/eyooo0rQ11n6wtjd8wSKaz0eYE52I7qAYHOKK/3TUADaSxQahqBgh9wtejzlRW/4YY/4c46BGLDiNMe/wIZnhNKT0tR/JgwisGsQea7WzxqE8UV9KZ4u0QE2dSSnSDVjDnf0AwysxPfGR5N2tGHJ0SFCzgfJmJSZ6rYWfy74iAmXwlYWgQOn1c2iSTX0PrTN4hNGyyfanT5T5fK4S9vP0CBSow2HQeP7FBJjFrvLGreQlVhrihBAmctPAqC893rpWy7woj4nxcTgAxqNl/Ag/X1TQcGMM3JVIRFwf4B3NBr7PYMF9YVrhuwy+SMaocsg0wraSYwQY6nQEkDoear81hygsCFWHVtsnG1I7zu6ojOmf5gTxoXkgqshEahValMF8vTYjrCGPhJa6TqTctvg9ZTYxsOJHFqIrRXTkoOXzKaTvrn5GYoSCp4bJN56Zw/dSBhPUUuELxH8SlMEnyu62HfsTCQeO6yugDphSl7Pv4f7IUkJV3WlnxcZ7uT+gEphQYNuWrnJXsnAazwVOH9cx5f0CVaqDA
[19:04]fr4n99._.: crendenciales github
[19:04]fr4n99._.: client id
Ov23liL9B4uH5DWLjN95
secrete github key
27314aa94a3d82465eb5c18dd3d21234714b40ba
[19:05]Paulaa <3[cute]
: https://waslab04-p1hk.onrender.com/
[19:13]fr4n99._.: AWS_ACCESS_KEY_ID=ASIA5KUMSLDO3CW3GT7J
AWS_SECRET_ACCESS_KEY=1auqkH0rztZiv7fiAv11w+4i4stNUeUXqSOVubJc
AWS_SESSION_TOKEN=IQoJb3JpZ2luX2VjEDMaCXVzLXdlc3QtMiJGMEQCIBn9igYfeQU5Fy3OXZV+Wuouf3XeQA/H1flIK4MOXW8SAiAh/MEGgM2K/nglX0aQxWaRbCzRWTtlIJtfF1ip/J4t4SrNAgis//////////8BEAAaDDkxNjE5NjU3OTU0OSIMrvcFmpUX7JENc1/gKqECrE2DSiSLLd7kB74j6I2VRwKcNarDas0fClr7XKdi9CvB0Cw2KQEyv1/PSjiOaHKO7xzfFh8+9ZqMMRGOGb3KC2r+gr4sg87Kw10fEqIUrMEH6Mgfg8eS9XbCEzPu0aiKOXiy1By4PK5JvLOOf1WS20Ca973KnYEw8AvAkR4YS/gPg4qag9CVQD9Q0X56uM+0KlA2rt63c2l9htxA8BudmXuRNI9XYF4l86RoRkGfdKaEoEOCRcKWPNaa9g0ox83iZge+KtX17GxWxESwuVHtD0gs+LdPhfMgA4dh6lfE0Ke0oJ+6hqAEtR3PuywZNRh+uQjkkFQH/UcNRWZrec968d045/6HrO2IrygwqcOXKAMnrQsibCTNMfqB5ka+p8JqNTDQo+C/BjqeAXYyIW41YP6k0+cE62EsKSHBBaRwRFidja6ViTIvoCLnTCO+x7jTaxiLlfMX0y5vUyLCc/X3NJxTe3qdAyyv7+/iRjhXXrHs8OlL7xTP7DCy+ko8UcBxItE7M+06ZSTYFsOS12IOirluEoqGAQGj9rjrWH1kw8Y+TXImANsK51JLsCTwMapxc9VuFV3JwacJcZIk/4Dhfe4fXtWxZRHm
GITHUB_APP_ID=Ov23liLPHbGxvv9JxXEH
GITHUB_APP_SECRET=cc8480a5e8f1bf08d92f81b8bc7deafbe639880a
C9_HOSTNAME=07ba3ba9a50847f58b81c6b9339ed857.vfs.cloud9.us-east-1.amazonaws.com
GITHUB_CALLBACK_URL=https://07ba3ba9a50847f58b81c6b9339ed857.vfs.cloud9.us-east-1.amazonaws.com/users/auth/github/callback
[19:20]fr4n99._.:
module Api
  module V1
    class IssuesController < BaseController
      # Ya no es necesario omitir verificación CSRF, se maneja en BaseController
      # Incluir todas las acciones que necesitan el callback set_issue
      before_action :set_issue, only: [:show, :update, :destroy, :attachments, :add_attachment, :delete_attachment]
Expandir
message.txt
14 KB
[19:46]fr4n99._.:
Imagen
[19:47]fr4n99._.: render json: @issues.as_json(include: [:issue_type, :severity, :priority, :status, :user, :assignee], attachments_count: true)
[19:47]fr4n99._.:
Sobrescribir el método as_json para controlar qué se serializa,
  def as_json(options = {})
    # Llamar al método original para obtener la serialización base
    json = super(options)

Si se solicitan los adjuntos, serializarlos de forma segura,
    if options[:include_attachments]
      json['attachments'] = attachments.map do |attachment|
        {
          id: attachment.id,
          filename: attachment.filename.to_s,
          content_type: attachment.content_type,
          created_at: attachment.created_at,
          url: Rails.application.routes.url_helpers.rails_blob_path(attachment, only_path: true)
        }
      end
    elsif options[:attachments_count]
      # Solo incluir el contador de adjuntos
      json['attachments_count'] = attachments.count
    end

Eliminar cualquier información sensible que pueda haberse incluido,
    json.delete('access_key_id') if json.key?('access_key_id')
    json.delete('secret_access_key') if json.key?('secret_access_key')
    json.delete('session_token') if json.key?('session_token')

    json
  end
[19:47]fr4n99._.: """
[19:47]fr4n99._.:
Usar el método as_json personalizado con la opción de incluir adjuntos seguros,
        render json: @issue.as_json(include: [:issue_type, :severity, :priority, :status, :user, :comments], include_attachments: true)
[19:50]fr4n99._.:
Imagen
[19:50]fr4n99._.:
  # Sobrescribir el método as_json para controlar qué se serializa
  def as_json(options = {})
    # Llamar al método original para obtener la serialización base
    json = super(options)

    # Si se solicitan los adjuntos, serializarlos de forma segura
Expandir
popo.txt
2 KB
[20:14]fr4n99._.:
module Api
  module V1
    class IssuesController < ApplicationController
      # Omitir verificación CSRF para API
      skip_before_action :verify_authenticity_token
      # Incluir todas las acciones que necesitan el callback set_issue
      before_action :set_issue, only: [:show, :update, :destroy, :attachments, :add_attachment, :delete_attachment]

      # GET /api/v1/issues
      def index
        @issues = Issue.all.includes(:issue_type, :severity, :priority, :status, :user, :assignee)

        # Validar parámetros de ordenación
        if params[:order_by].present? ^ params[:order_direction].present?
          return render json: { error: "Para ordenar los issues, debes especificar tanto 'order_by' como 'order_direction'" }, status: :bad_request
        end

        # Aplicar filtros usando scopes
        # Filtros por texto
        @issues = @issues.filtrar_por_titulo(params[:titulo]) if params[:titulo].present?
        @issues = @issues.filtrar_por_descripcion(params[:descripcion]) if params[:descripcion].present?

        # Filtros por ID
        @issues = @issues.por_tipo(params[:issue_type_id]) if params[:issue_type_id].present?
        @issues = @issues.por_severidad(params[:severity_id]) if params[:severity_id].present?
        @issues = @issues.por_prioridad(params[:priority_id]) if params[:priority_id].present?
        @issues = @issues.por_estado(params[:status_id]) if params[:status_id].present?
        @issues = @issues.por_creador(params[:user_id]) if params[:user_id].present?
        @issues = @issues.por_asignado(params[:assignee_id]) if params[:assignee_id].present?

        # Filtros por nombre
        @issues = @issues.por_tipo_nombre(params[:type]) if params[:type].present?
        @issues = @issues.por_severidad_nombre(params[:severity]) if params[:severity].present?
        @issues = @issues.por_prioridad_nombre(params[:priority]) if params[:priority].present?
        @issues = @issues.por_estado_nombre(params[:status]) if params[:status].present?

        # Aplicar ordenación personalizada si se especifican ambos parámetros, sino ordenar por fecha de actualización
        if params[:order_by].present? && params[:order_direction].present?
          @issues = apply_order(@issues)
        else
          @issues = @issues.order(updated_at: :desc)
        end

        render json: @issues.as_json(include: {
          issue_type: {},
          severity: {},
          priority: {},
          status: {},
          user: { except: [:api_key] },
          assignee: { except: [:api_key] }
        })
      end

      # GET /api/v1/issues/:id
      def show
        render json: @issue.as_json(include: {
          issue_type: {},
          severity: {},
          priority: {},
          status: {},
          user: { except: [:api_key] },
          comments: { include: { user: { except: [:api_key] } } }
        })
      end

      # POST /api/v1/issues
      def create
        @issue = Issue.new(issue_params)

        # Asignar usuario: primero intentar con current_user, luego con params[:user_id], y finalmente usar el primer usuario disponible
        if current_user
          @issue.user_id = current_user.id
        elsif params[:user_id].present?
          @issue.user_id = params[:user_id]
        else
          # Usar el primer usuario disponible como fallback
          @issue.user_id = User.first&.id || 1 # Usar ID 1 como último recurso
        end

        if @issue.save
          render json: @issue, status: :created
        else
          render json: { errors: @issue.errors }, status: :unprocessable_entity
        end
      end

      # PATCH/PUT /api/v1/issues/:id
      def update
        begin
          return render json: { error: "Debe proporcionar al menos un campo para actualizar" }, status: :unprocessable_entity if params[:issue].blank?

          # Sanear los parámetros para evitar errores
          update_params = issue_params

          # Manejar el campo deadline
          if update_params.key?(:deadline)
            if update_params[:deadline].blank?
              # Si deadline está vacío, establecerlo a nil
              update_params[:deadline] = nil
            else
... (141 líneas restantes)
Contraer
message.txt
10 KB

fr4n99._.
fr4n99._.


module Api
  module V1
    class IssuesController < ApplicationController
      # Omitir verificación CSRF para API
      skip_before_action :verify_authenticity_token
      # Incluir todas las acciones que necesitan el callback set_issue
      before_action :set_issue, only: [:show, :update, :destroy, :attachments, :add_attachment, :delete_attachment]

      # GET /api/v1/issues
      def index
        @issues = Issue.all.includes(:issue_type, :severity, :priority, :status, :user, :assignee)

        # Validar parámetros de ordenación
        if params[:order_by].present? ^ params[:order_direction].present?
          return render json: { error: "Para ordenar los issues, debes especificar tanto 'order_by' como 'order_direction'" }, status: :bad_request
        end

        # Aplicar filtros usando scopes
        # Filtros por texto
        @issues = @issues.filtrar_por_titulo(params[:titulo]) if params[:titulo].present?
        @issues = @issues.filtrar_por_descripcion(params[:descripcion]) if params[:descripcion].present?

        # Filtros por ID
        @issues = @issues.por_tipo(params[:issue_type_id]) if params[:issue_type_id].present?
        @issues = @issues.por_severidad(params[:severity_id]) if params[:severity_id].present?
        @issues = @issues.por_prioridad(params[:priority_id]) if params[:priority_id].present?
        @issues = @issues.por_estado(params[:status_id]) if params[:status_id].present?
        @issues = @issues.por_creador(params[:user_id]) if params[:user_id].present?
        @issues = @issues.por_asignado(params[:assignee_id]) if params[:assignee_id].present?

        # Filtros por nombre
        @issues = @issues.por_tipo_nombre(params[:type]) if params[:type].present?
        @issues = @issues.por_severidad_nombre(params[:severity]) if params[:severity].present?
        @issues = @issues.por_prioridad_nombre(params[:priority]) if params[:priority].present?
        @issues = @issues.por_estado_nombre(params[:status]) if params[:status].present?

        # Aplicar ordenación personalizada si se especifican ambos parámetros, sino ordenar por fecha de actualización
        if params[:order_by].present? && params[:order_direction].present?
          @issues = apply_order(@issues)
        else
          @issues = @issues.order(updated_at: :desc)
        end

        render json: @issues.as_json(include: {
          issue_type: {},
          severity: {},
          priority: {},
          status: {},
          user: { except: [:api_key] },
          assignee: { except: [:api_key] }
        })
      end

      # GET /api/v1/issues/:id
      def show
        render json: @issue.as_json(include: {
          issue_type: {},
          severity: {},
          priority: {},
          status: {},
          user: { except: [:api_key] },
          comments: { include: { user: { except: [:api_key] } } }
        })
      end

      # POST /api/v1/issues
      def create
        @issue = Issue.new(issue_params)

        # Asignar usuario: primero intentar con current_user, luego con params[:user_id], y finalmente usar el primer usuario disponible
        if current_user
          @issue.user_id = current_user.id
        elsif params[:user_id].present?
          @issue.user_id = params[:user_id]
        else
          # Usar el primer usuario disponible como fallback
          @issue.user_id = User.first&.id || 1 # Usar ID 1 como último recurso
        end

        if @issue.save
          render json: @issue, status: :created
        else
          render json: { errors: @issue.errors }, status: :unprocessable_entity
        end
      end

      # PATCH/PUT /api/v1/issues/:id
      def update
        begin
          return render json: { error: "Debe proporcionar al menos un campo para actualizar" }, status: :unprocessable_entity if params[:issue].blank?

          # Sanear los parámetros para evitar errores
          update_params = issue_params

          # Manejar el campo deadline
          if update_params.key?(:deadline)
            if update_params[:deadline].blank?
              # Si deadline está vacío, establecerlo a nil
              update_params[:deadline] = nil
            else
              # Validar que la fecha sea posterior a hoy
              deadline_date = Date.parse(update_params[:deadline])
              if deadline_date <= Date.today
                return render json: { error: "La fecha límite debe ser posterior a hoy" }, status: :unprocessable_entity
              end
            end
          end

          # Manejar watchers
          if update_params.key?(:watcher_ids)
            # Si es nil o vacío, eliminar todos los watchers
            if update_params[:watcher_ids].nil? || update_params[:watcher_ids].empty?
              @issue.watchers.clear
              update_params.delete(:watcher_ids)
            else
              # Convertir a array y asegurar que son números
              watcher_ids = Array(update_params[:watcher_ids]).map(&:to_i).compact
              # Verificar que los usuarios existen
              unless User.where(id: watcher_ids).count == watcher_ids.length
                return render json: { error: "Algunos IDs de watchers no son válidos" }, status: :unprocessable_entity
              end
              update_params[:watcher_ids] = watcher_ids
            end
          end

          # Intentar actualizar el issue solo con los campos proporcionados
          if @issue.update(update_params)
            render json: @issue.as_json(include: {
              issue_type: {},
              severity: {},
              priority: {},
              status: {},
              user: { except: [:api_key] },
              watchers: { except: [:api_key] }
            })
          else
            render json: { errors: @issue.errors }, status: :unprocessable_entity
          end
        rescue Date::Error
          render json: { error: "Formato de fecha inválido. Use el formato YYYY-MM-DD" }, status: :unprocessable_entity
        rescue => e
          # Capturar cualquier excepción y devolver un mensaje de error claro
          Rails.logger.error("Error al actualizar issue: #{e.message}\n#{e.backtrace.join("\n")}")
          render json: { error: "Error al actualizar el issue: #{e.message}" }, status: :internal_server_error
        end
      end

      # DELETE /api/v1/issues/:id
      def destroy
        @issue.destroy
        head :no_content
      end

      private

      def set_issue
        @issue = Issue.find(params[:id])
      end

      def issue_params
        params.require(:issue).permit(:subject, :content, :issue_type_id, :severity_id, :priority_id, :status_id, :assignee_id, :user_id, :deadline, watcher_ids: [])
      end

      def apply_order(issues)
        order_by = params[:order_by].to_s.downcase
        direction = (params[:order_direction]&.downcase == 'desc') ? 'desc' : 'asc'

        case order_by
        when 'type'
          issues.joins(:issue_type).order("issue_types.name #{direction}")
        when 'severity'
          issues.joins(:severity).order("severities.name #{direction}")
        when 'priority'
          issues.joins(:priority).order("priorities.name #{direction}")
        when 'status'
          issues.joins(:status).order("statuses.name #{direction}")
        when 'modified'
          issues.order(updated_at: direction)
        when 'assign_to'
          issues.joins(:assignee).order("users.username #{direction}")
        when 'issue'
          issues.order(id: direction)
        when ''
          # Si no hay order_by, ordenar por fecha de modificación descendente
          issues.order(updated_at: :desc)
        else
          # Para cualquier otro valor no reconocido, ordenar por fecha de modificación descendente
          issues.order(updated_at: :desc)
        end
      end

      # GET /api/v1/issues/:id/attachments
      def attachments
        attachments_with_urls = @issue.attachments.map do |attachment|
          {
            id: attachment.id,
            filename: attachment.filename.to_s,
            content_type: attachment.content_type,
            created_at: attachment.created_at,
            url: Rails.application.routes.url_helpers.rails_blob_path(attachment, only_path: true)
          }
        end

        render json: attachments_with_urls
      end

      # POST /api/v1/issues/:id/attachments
      def add_attachment
        if params[:attachment].present?
          @issue.attachments.attach(params[:attachment])
          attachment = @issue.attachments.last

          render json: {
            id: attachment.id,
            filename: attachment.filename.to_s,
            content_type: attachment.content_type,
            created_at: attachment.created_at,
            url: Rails.application.routes.url_helpers.rails_blob_path(attachment, only_path: true)
          }, status: :created
        else
          render json: { error: "No attachment provided" }, status: :unprocessable_entity
        end
      end

      # DELETE /api/v1/issues/:id/attachments/:attachment_id
      def delete_attachment
        attachment = ActiveStorage::Attachment.find_by(id: params[:attachment_id])

        if attachment.nil?
          render json: { error: "Attachment not found" }, status: :not_found
        elsif attachment.record_id != @issue.id
          render json: { error: "Attachment does not belong to this issue" }, status: :forbidden
        else
          attachment.purge
          head :no_content
        end
      end
    end
  end
end
message.txt
10 KB